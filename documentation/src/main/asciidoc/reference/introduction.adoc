[[getting-started]]
= Introduction to Hibernate Reactive

:example: https://github.com/hibernate/hibernate-reactive/tree/master/example

Creating a new project with Hibernate Reactive isn't hard at all. In this
short guide, we'll cover all the basic work involved in:

- setting up and configuring a project, and then
- writing Java code to define a data model and access the database.

But, before you start, we recommend taking a quick look at the example
program in the {example}[`example`] directory, which shows off all the
"bits" you'll need to get your own program up and running.

== Setting up a reactive Hibernate project

:skeleton: https://code.quarkus.io/?g=org.acme&a=code-with-quarkus&v=1.0.0-SNAPSHOT&b=MAVEN&c=org.acme.ExampleResource&s=r1s.8XW.fmW.ih0&cn=code.quarkus.io

If you're using Hibernate Reactive outside of the Quarkus environment,
you'll need to:

- include Hibernate Reactive itself along with the appropriate Vert.x
  reactive database client as dependencies of your project, and
- configure Hibernate Reactive with information about your database,
  using Hibernate configuration properties.

Or, if you want to use Hibernate Reactive in Quarkus, you can generate
a preconfigured skeleton project {skeleton}[right here].

=== Including Hibernate Reactive in your project build

:build: https://github.com/hibernate/hibernate-reactive/blob/master/example/build.gradle

Add the following dependency to your project:

----
org.hibernate.reactive:hibernate-reactive-core:{version}
----

Where `{version}` is the version of Hibernate Reactive you're using.

You'll also need to add a dependency for the Vert.x reactive database
driver for your database, one of the following options:

|===
| Database   | Driver dependency

| PostgreSQL | `io.vertx:vertx-pg-client:{vertxVersion}`
| MySQL      | `io.vertx:vertx-mysql-client:{vertxVersion}`
| DB2        | `io.vertx:vertx-db2-client:{vertxVersion}`
|===

Where `{vertxVersion}` is the version of Vert.x compatible with the
version of Hibernate Reactive you're using.

You don't need to depend on the JDBC driver for your database (but you
can if you like).

=== Optional dependencies

:slf4j: http://www.slf4j.org/
:enhancer: https://docs.jboss.org/hibernate/orm/5.4/topical/html_single/bytecode/BytecodeEnhancement.html

Optionally, you might also add any of the following additional features:

|===
| Optional feature | Dependencies

| An {slf4j}[SLF4J] logging implementation | `org.slf4j:slf4j-log4j12` or `org.slf4j:slf4j-jdk14`
| The Hibernate metamodel generator, if you're using the JPA criteria query API | `org.hibernate:hibernate-jpamodelgen`
| Hibernate Validator | `org.hibernate.validator:hibernate-validator` and `org.glassfish:jakarta.el`
| Compile-time checking for your HQL queries | `org.hibernate:query-validator`
| Second-level cache support via JCache and EHCache | `org.hibernate:hibernate-jcache` along with `org.ehcache:ehcache`
|===

You might also add the Hibernate {enhancer}[bytecode enhancer] to your
Gradle build if you want to use field-level  lazy fetching.

TIP: Field-level lazy fetching is an advanced feature that most programs
don't need. Stick to the basics for now.

There's an example {build}[Gradle build] included in the example program.

=== Configuration

:xml: https://github.com/hibernate/hibernate-reactive/blob/master/example/src/main/resources/META-INF/persistence.xml
:configuration-properties: https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#configurations


Hibernate Reactive is configured via the standard JPA `persistence.xml`
document which must be placed, as usual, in the `/META-INF` directory.

The only configuration specific to Hibernate Reactive is the persistence
`<provider>` element, which must be explicit:

[source,xml]
----
<provider>org.hibernate.reactive.provider.ReactivePersistenceProvider</provider>
----

Otherwise, configuration is almost completely transparent. Configure
Hibernate exactly as you usually would, noting that most configuration
properties directly related to JDBC or JTA aren't relevant in the context
of Hibernate Reactive.

A full list of configuration properties recognized by Hibernate may be
found in the {configuration-properties}[documentation for Hibernate ORM].
Configuration properties of particular interest include:

|===
| Configuration property name                                         | Purpose

| `javax.persistence.jdbc.url`                                        | JDBC URL of your database
| `javax.persistence.jdbc.user` and `javax.persistence.jdbc.password` | Your database credentials
| `javax.persistence.schema-generation.database.action`               | Value `create` enables automatic schema export
| `hibernate.jdbc.batch_size`                                         | Maximum batch size for SQL statement batching
|===

These configuration properties have `jdbc` in their names, but of course
there's no JDBC in Hibernate Reactive, and these are simply the legacy
property names defined by the JPA specification and Hibernate ORM. In
particular, Hibernate Reactive itself parses and interprets the JDBC URL.

TIP: You don't need to specify `hibernate.dialect`. The correct Hibernate
`Dialect` will be determined for you by Hibernate Reactive.

An example {xml}[`persistence.xml`] file is included in the example
program.

=== Logging the generated SQL

:log4j: https://github.com/hibernate/hibernate-reactive/blob/master/example/src/main/resources/log4j.properties

To see the generated SQL as it's sent to the database, either:

- set the property `hibernate.show_sql` to `true`, or
- enable debug-level logging for the category `org.hibernate.SQL`
  using your preferred SLF4J logging implementation.

For example, if you're using Log4J via `slf4j-log4j12` (as above in
<<_optional_dependencies>>), add this line to your `log4j.properties`
file:

[source,properties]
----
log4j.logger.org.hibernate.SQL=DEBUG
----

An example {log4j}[`log4j.properties`] file is included in the example
program.

=== Tuning the Vert.x pool

The Vert.x database client has built-in connection pooling and prepared
statement caching. You might want to control the size of the connection
pool:

|===
| Configuration property name      | Purpose

| `hibernate.connection.pool_size` | The maximum size of the reactive connection pool
|===

When it comes time for performance tuning, you can further customize the
pool and cache via the following properties:

|===
| Configuration property name                          | Purpose

| `hibernate.vertx.pool.max_wait_queue_size`           | The maximum connection requests allowed in the wait queue
| `hibernate.vertx.prepared_statement_cache.max_size`  | The maximum size of the prepared statement cache
| `hibernate.vertx.prepared_statement_cache.sql_limit` | The maximum length of prepared statement SQL string that will be cached
|===

TIP: But for now, just leave these three settings alone.

Finally, for more advanced cases, you can write your own code to configure
the Vert.x client by implementing `SqlClientPoolConfiguration`.

|===
| Configuration property name      | Purpose

| `hibernate.vertx.pool.configuration_class` | A class implementing `SqlClientPoolConfiguration`
|===

=== Enabling the second-level cache

:second-level-cache: https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#caching

Hibernate Reactive supports second-level cache implementations that
perform no blocking I/O.

IMPORTANT: Make sure you disable any disk-based storage or distributed
replication used by your preferred cache implementation. A second-level
cache which uses blocking I/O to interact with the network or disk-based
storage will at least partially negate the advantages of the reactive
programming model.

Configuring Hibernate's second-level cache is a rather involved topic,
and quite outside the scope of this document. But in case it helps, we're
testing Hibernate Reactive with the following configuration, which uses
EHCache as the cache implementation, as above in <<_optional_dependencies>>:

|===
| Configuration property name              | Property value

| `hibernate.cache.use_second_level_cache` | `true`
| `hibernate.cache.region.factory_class`   | `org.hibernate.cache.jcache.JCacheRegionFactory`
| `hibernate.javax.cache.provider`         | `org.ehcache.jsr107.EhcacheCachingProvider`
| `hibernate.javax.cache.uri`              | `/ehcache.xml`
|===

If you're using EHCache, you'll also need to include an `ehcache.xml` file
that explicitly configures the behavior of each cache region belonging to
your entities and collections.

TIP: Don't forget that you need to explicitly mark each entity that will
be stored in the second-level cache with the `@Cache` annotation from
`org.hibernate.annotations`.

You can find much more information about the second-level cache in the
{second-level-cache}[documentation for Hibernate ORM].

== Writing the Java code

With that out of the way, we're all set to write some Java code!

As is the case in any project that uses Hibernate, your
persistence-related code comes in two main pieces:

. a representation of your data model in Java, which takes the form
  of a set of annotated entity classes, and
. a larger number of functions which interact with Hibernate's APIs
  to perform the persistence operations associated with your various
  transactions.

The first part, the data or "domain" model, is usually easier to write,
but doing a great and very clean job of it will strongly affect your
success in the second part.

TIP: Take your time with this code, and try to produce a Java model
that's as close as reasonable to the relational data model. Avoid using
exotic or advanced mapping features when they're not really needed.
When in the slightest doubt, map a foreign key relationship using
`@ManyToOne` with `@OneToMany(mappedBy=...)` in preference to more
complicated association mappings.

The second part of the code is much trickier to get right. This code must:

- manage transactions and reactive sessions,
- construct reactive streams by chaining persistence operations invoked
  on the reactive session,
- fetch and prepare data needed by the UI, and
- handle failures.

TIP: Some responsibility for transaction and session management, and for
recovery from certain kinds of failure, can be best handled in some sort
of framework code.

=== Mapping entity classes

:mapping-annotations: https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#annotations
:bean-validation: https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#chapter-bean-constraints

We won't have much to say about the entity classes here, simply because
the principles behind mapping entity classes in Hibernate Reactive,
along with the actual mapping annotations you'll use, are all identical
to regular Hibernate ORM and other implementations of JPA.

For example:

[source,java]
----
@Entity
@Table(name="authors")
class Author {
    @Id @GeneratedValue
    Integer id;

    @NotNull @Size(max=100)
    String name;

    @OneToMany(mappedBy = "author", cascade = PERSIST)
    List<Book> books = new ArrayList<>();

    Author(String name) {
        this.name = name;
    }

    Author() {}
}
----

You're quite free to mix and match:

- the regular JPA mapping annotations defined in the package
  `javax.persistence` with
- the advanced mapping annotations in `org.hibernate.annotations`, and even
- annotations like `@NotNull` and `@Size` defined by Bean Validation.

A full list of object/relational mapping annotations may be found in the
{mapping-annotations}[documentation for Hibernate ORM]. Most mapping
annotations are already supported in Hibernate Reactive, though there are
still a handful of limitations at this time.

Information about Bean Validation annotations may be found in the
{bean-validation}[documentation for Hibernate Validator].

=== Identifier generation

One area where the functionality of Hibernate Reactive diverges from plain
Hibernate is in the area of id generation. Custom identifier generators
written to work with Hibernate ORM and JDBC will _not_ work in the reactive
environment.

- Sequence, table, and `UUID` id generation is built in, and these id
  generation strategies may be selected using the usual JPA mapping
  annotations: `@GeneratedValue`, `@TableGenerator`, `@SequenceGenerator`.
- Natural ids&mdash;including composite ids&mdash;may be assigned by the
  program in the usual way.
- Custom id generators may be defined by implementing `ReactiveIdentifierGenerator`
  and declaring the custom implementation using `@GenericGenerator`.

=== Custom types

Hibernate custom types based on the `UserType` interface are similarly
targeted toward JDBC. Hibernate Reactive features an adaptor that exposes a
partial implementation of JDBC to the `UserType` implementation.

Therefore, _some_ existing `UserType` implementations will work in Hibernate
Reactive, depending upon precisely which features of JDBC they depend on.

TIP: Where possible, use a JPA `AttributeConverter` instead of a `UserType`,
since JPA converters are not in any way tied to JDBC.

=== APIs for chaining reactive operations

:Mutiny: https://smallrye.io/smallrye-mutiny/

When you write persistence logic using Hibernate Reactive, you'll be working
with a reactive `Session` most of the time. Just to make things a little more
confusing for new users, the reactive `Session` and its related interfaces all
come in two flavors:

- `Stage.Session` and friends provide a reactive API based around Java's
`CompletionStage`, and
- `Mutiny.Session` and friends provide an API based on {Mutiny}[Mutiny].

You'll need to decide which API you want to use!

TIP: If you take the time to look over the types `Stage.Session` and
`Mutiny.Session`, you'll notice they're almost identical. Choosing between
them is a matter of deciding which reactive API you want to use for working
with reactive streams. Your decision won't affect what you can do with
Hibernate Reactive.

These are the most important operations on reactive streams that you'll need
all the time when working with Hibernate Reactive:

|===
| Purpose                                  | Java `CompletionStage` | Mutiny `Uni`

| Chain non-blocking operations            | `thenCompose()`        | `chain()` or `then()`
| Transform streamed items                 | `thenApply()`          | `map()`
| Perform an action using streamed items   | `thenAccept()`         | `invoke()` or `invokeUni()`
| Perform cleanup (similar to `finally`)   | `whenComplete()`       | `eventually()`
|===

In this introduction, our code examples usually use `CompletionStage`, since
that's what more people are already familiar with. But please don't take that
as a recommendation for what _you_ should do.

When we use the term _reactive stream_ in this document, we mean:

- a chain of ``CompletionStage``s, or
- a chain of Mutiny ``Uni``s and ``Multi``s

that is built by the program in order to service a particular request,
transaction, or unit of work.

=== Obtaining a reactive session factory

Whatever you decide, the first step to getting a reactive session is to obtain
a JPA `EntityManagerFactory` just as you usually would in plain ol' regular JPA,
for example, by calling:

[java]
----
EntityManagerFactory emf = Persistence.createEntityManagerFactory("example");
----

Now, `unwrap()` the reactive `SessionFactory`. If you want to use
``CompletionStage``s for chaining reactive operations, ask for a
`Stage.SessionFactory`:

[java]
----
Stage.SessionFactory sessionFactory = emf.unwrap(Stage.SessionFactory.class);
----

Or, if you prefer to use the Mutiny-based API, `unwrap()` the type
`Mutiny.SessionFactory`:

[java]
----
Mutiny.SessionFactory sessionFactory = emf.unwrap(Mutiny.SessionFactory.class);
----

Reactive sessions may be obtained from the resulting reactive `SessionFactory`.

TIP: It's also possible to construct a reactive `SessionFactory` via programmatic
configuration based on Hibernate's `ServiceRegistry` architecture, by using a
`ReactiveServiceRegistryBuilder`. But that's outside the scope of this document.

=== Obtaining a reactive session

Persistence operations are exposed via a reactive `Session` object. It's very
important to understand that most operations of this interface are non-blocking,
and execution of SQL against the database is never performed synchronously.
Persistence operations that belong to a single unit of work must be chained by
composition within a single reactive stream.

Also remember that a Hibernate session is a lightweight object that should be
created, used, and then discarded within a single logical unit of work.

TIP: That is to say, you should reuse the same session across multiple
persistence operations within a single reactive stream representing a certain
unit of work, but don't share a session between different reactive streams!

To obtain a reactive `Session` from the `SessionFactory`, use `withSession()`:

[java]
----
sessionFactory.withSession(
        session -> session.find(Book.class, id)
                .thenAccept(
                    book -> ... //do something with the book
                )
);
----

Alternatively, you may use `openSession()`, but you must remember to `close()`
the session when you're done.

[java]
----
Session session = sessionFactory.openSession();
session.find(Book.class, id)
        .thenAccept(
            book -> ... //do something with the book
        )
        .whenComplete( (v,e) -> session.close() );
----

=== Using the reactive session

The `Session` interface has methods with the same names as methods of the
JPA `EntityManager`. You might already be familiar with the following session
operations defined by JPA:

|===
| Method name and parameters | Effect

| `find(Class,Object)` | Obtain a persistent object given its type and its id
                         (primary key)
| `persist(Object)`    | Make a transient object persistent and schedule a SQL
                         `insert` statement for later execution
| `remove(Object)`     | Make a persistent object transient and schedule a SQL
                         `delete` statement for later execution
| `merge(Object)`      | Copy the state of a given transient object to a
                         corresponding persistent instance and return the
                         persistent object
| `refresh(Object)`    | Refresh the persistent state of an object using a new
                         SQL `select` to retrieve the current state from the
                         database
| `lock(Object)`       | Obtain a pessimistic lock on a persistent object
| `flush()`            | Detect changes made to persistent objects association
                         with the session and synchronize the database state
                         with the state of the session by executing SQL `insert`,
                         `update`, and `delete` statements
| `detach(Object)`     | Disassociate a persistent object from a session without
                         affecting the database
|===

If you're not familiar with these operations, don't despair! Their semantics
are defined in the JPA specification, and in the API documentation, and are
explained in innumerable articles and blog posts. But if you already have some
experience with Hibernate or JPA, you're right at home!

Now, _here's where Hibernate Reactive is different:_ in the reactive API, each
of these methods returns its result in a non-blocking fashion via a Java
`CompletionStage` (or Mutiny `Uni`). For example:

[java]
----
session1.find(Book.class, book.id)
        .thenAccept( book -> System.out.println(book.title + " is a great book!") )
----

On the other hand, methods with no meaningful return value just return a
reference to the `Session`, again via a `CompletionStage` (or `Uni`).

[java]
----
session2.find(Book.class, id)
        .thenCompose( book -> session.remove(book) )
        .thenCompose( s -> session.flush() )
        .whenComplete( (s,e) -> session.close() )
----

TIP: The session will be flushed automatically at the end of a unit of work
if&mdash;and _only_ if&mdash;you use a transaction, as described below in
<<_transactions>>. If you don't use a transaction, and forget to flush the
session explicitly, your persistence operations might never be sent to the
database!

An _extremely_ common mistake when using reactive streams is to forget to
chain the return value of a "void-like" method. For example, in the following
code, the `flush()` operation is never executed, because `thenAccept()`
doesn't chain its return value to the tip of the stream.

[java]
----
session.find(Book.class, id)
        .thenCompose( book -> session.remove(book) )
        .thenAccept( session -> session.flush() )   //OOPS, WRONG!!
        .whenComplete( (session,e) -> session.close() )
----

The same problem occurs in the following code, but this time it's `remove()`
that never gets called:

[java]
----
session.find(Book.class, id)
        .thenCompose( book -> {
            session.remove(book);   //OOPS, WRONG!!
            return session.flush();
        } )
----

If you already have some experience with reactive programming, there's nothing
new to learn here. But if you _are_ new to reactive programming, just be aware
that you're going to make this mistake, in some form, _at least_ once!

=== Queries

Naturally, the `Session` interface is a factory for `Query` instances which
allow you to set query parameters and execute queries and DML statements:

|===
| Method name           | Effect

| `createQuery()`       | Obtain a `Query` for executing a query or DML
                          statement written in HQL or JPQL
| `createNativeQuery()` | Obtain a `Query` for executing a query or DML
                          statement written in the native SQL dialect of
                          your database
| `createNamedQuery()`  | Obtain a `Query` for executing a named HQL or SQL
                          query defined by a `@NamedQuery` annotation
|===

That `createQuery()` method produces a reactive `Query`, allowing HQL / JPQL
queries to be executed asynchronously, always returning their results via a
`CompletionStage` (or `Uni`):

[java]
----
session3.createQuery("select title from Book order by title desc")
        .getResultList()
        .thenAccept(System.out::println)
----

The `Query` interface defines the following important operations:

|===
| Method name         | Effect

| `setParameter()`    | Set an argument of a query parameter
| `setMaxResults()`   | Limit the number of results returned by the query
| `setFirstResult()`  | Specify a certain number of initial results to
be skipped (for result pagination)
| `getSingleResult()` | Execute a query and obtain the single result
| `getResultList()`   | Execute a query and obtain the results as a list
| `executeUpdate()`   | Execute a DML statement and obtain the number of
affected rows
|===

TIP: The Hibernate Reactive `Query` API doesn't support `java.util.Date`
or its subclasses in `java.sql`, nor `java.util.Calendar`. Always use
`java.time` types like `LocalDate` or `LocalDateTime` for specifying
arguments to temporally-typed query parameters.

For  JPA criteria queries, you must first obtain the `CriteriaBuilder` using
`SessionFactory.getCriteriaBuilder()`, and execute your query using
`Session.createQuery()`.

[java]
----
CriteriaQuery<Book> query = factory.getCriteriaBuilder().createQuery(Book.class);
Root<Author> a = query.from(Author.class);
Join<Author,Book> b = a.join(Author_.books);
query.where( a.get(Author_.name).in("Neal Stephenson", "William Gibson") );
query.select(b);
return session.createQuery(query).getResultList().thenAccept(
        books -> books.forEach(book -> out.println(book.title))
);
----

=== Fetching lazy associations

In Hibernate ORM, a lazy association is fetched transparently when the
association is first accessed within a session. In Hibernate Reactive, on
the other hand, lazy association fetching is an asynchronous process that
produces a result via a `CompletionStage` (or `Uni`).

Therefore, lazy fetching is an explicit operation named `fetch()`, a static
method of `Stage` and `Mutiny`:

[java]
----
session4.find(Author.class, author.id)
        .thenCompose( author -> Stage.fetch(author.books) )
        .thenAccept( books -> ... )
----

Of course, this isn't necessary if you fetch the association eagerly.

TIP: It's very important to make sure you've fetched all the data that
will be needed before passing control to the process that renders the
UI! There is no transparent lazy fetching in Hibernate Reactive, so
patterns like "open session in view" will _not help at all_.

=== Field-level lazy fetching

Similarly, field-level lazy fetching&mdash;an advanced feature, which
is only supported in conjunction with Hibernate's optional compile-time
bytecode enhancer&mdash;is also an explicit operation:

[java]
----
session5.find(Book.class, book.id)
        .thenCompose( book -> session.fetch(book, Book_.isbn) )
        .thenAccept( isbn -> ... )
----

Note that the field to fetch is identified by a JPA metamodel `Attribute`.

TIP: We don't encourage you to use field-level lazy fetching unless you
have very specific requirements.

=== A reminder about performance

:association-fetching: https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#fetching

As always, achieving high performance in ORM means minimizing the number
of round trips to the database. This goal should be uppermost in your
mind whenever you're writing data access code with Hibernate. The most
fundamental rule of thumb in ORM is:

- explicitly specify all the data you're going to need right at the start
of a session/transaction, and fetch it immediately in one or two queries,
- and only then start navigating associations between persistent entities.

TIP: Don't forget that most associations should be mapped for lazy
fetching by default. If you need eager fetching in some particular
transaction, use `left join fetch` in HQL, a fetch profile, a JPA
`EntityGraph`, or `fetch()` in a criteria query.

It follows from this tip that you shouldn't need to use `Stage.fetch()`
or `Mutiny.fetch()` very often!

TIP: Of course, Hibernate provides many other features that help you
minimize round trips to the database: DML SQL statement batching, the
second-level cache, batch fetching, subselect fetching, bulk update and
delete queries, and direct execution of native SQL are all things that
can help reduce the number of queries sent to the database.

You can find much more information about association fetching in the
{association-fetching}[documentation for Hibernate ORM].

=== Transactions

The `withTransaction()` method performs work within the scope of a database
transaction.

[java]
----
session.withTransaction( tx -> session.persist(book) )
----

The session is automatically flushed at the end of the transaction.

For extra convenience, there's a method that opens a session and starts a
transaction in one call:

[java]
----
sessionFactory.withTransaction( (session, tx) -> session.persist(book) )
----

Note that these are "resource local" transactions, delegated to the underlying
Vert.x database client. At present Hibernate Reactive does not integrate with
container-managed transactions.

=== Stateless sessions

An arguably-underappreciated feature of Hibernate is the `StatelessSession`
interface, which provides a command-oriented, more bare-metal approach to
interacting with the database.

You may obtain a reactive stateless session from the `SessionFactory`:

[java]
----
Stage.StatelessSession ss = getSessionFactory().openStatelessSession();
----

A stateless session:

- doesn't have a first-level cache (persistence context), nor does it interact
  with any second-level caches, and
- doesn't implement transactional write-behind or automatic dirty checking,
  so all operations are executed immediately when they're explicitly called.

In certain circumstances, this makes stateless sessions easier to work with,
but with the caveat that a stateless session is much more vulnerable to data
aliasing effects, since it's easy to get two non-identical Java objects which
both represent the same row of a database table.

In particular, the absence of a persistence context means that you can safely
perform bulk-processing tasks without allocating huge quantities of memory.
Use of a `StatelessSession` alleviates the need to call:

- `clear()` or `detach()` to perform first-level cache management, and
- `setCacheMode()` to bypass interaction with the second-level cache.

TIP: Stateless sessions can be useful, but for bulk operations on huge datasets,
Hibernate can't possibly compete with stored procedures!

When using a stateless session, you should be aware of the following additional
limitations:

- persistence operations never cascade to associated instances,
- collections are completely ignored, and
- operations performed via a stateless session bypass callbacks.

== Custom connection management and multitenancy

Hibernate Reactive supports custom management of reactive connections by letting
you define your own implementation of `ReactiveConnectionPool`, or extend the
built-in implementation `SqlClientPool`.

|===
| Configuration property name | Value

| `hibernate.vertx.pool.class` | A class which implements `ReactiveConnectionPool`
|===

A common motivation for defining a custom pool is the need to support multitenancy.
In a multitenant application, the database or database schema depends on the current
tenant identifier. The easiest way to set this up in Hibernate Reactive is to extend
`SqlClientPool` and override `getConnection(String tenantId)`.

For multitenancy, you'll also need to set at least one of the following
configuration properties defined by Hibernate ORM:

|===
| Configuration property name            | Value

| `hibernate.multiTenancy`               | The multitenancy strategy: `database` or `schema`
| `hibernate.tenant_identifier_resolver` | (Optional) A class which implements `CurrentTenantIdentifierResolver`
|===

== Next steps

:Quarkus: https://quarkus.io/
:Panache: https://quarkus.io/guides/hibernate-orm-panache

Hibernate Reactive is now integrated in {Quarkus}[Quarkus] and {Panache}[Panache].
Configuration works slightly differently in Quarkus, so be sure to check the Quarkus
documentation for details.